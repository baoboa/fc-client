/*
 * Copyright (C) 2014 Red Hat, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the licence, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Matthew Barnes <mbarnes@redhat.com>
 */

#include "config.h"

#include "fcmdr-yum-backend.h"

#include <errno.h>
#include <glib/gstdio.h>

#include "fcmdr-extensions.h"

#define FCMDR_YUM_PREAMBLE \
	"# Generated by " G_LOG_DOMAIN ". DO NOT EDIT.\n\n"

#define FCMDR_YUM_REPOS_DIR "/etc/yum.repos.d"

G_DEFINE_TYPE_WITH_CODE (
	FCmdrYumBackend,
	fcmdr_yum_backend,
	FCMDR_TYPE_SERVICE_BACKEND,
	fcmdr_ensure_extension_points_registered ();
	g_io_extension_point_implement (
		FCMDR_SERVICE_BACKEND_EXTENSION_POINT_NAME,
		g_define_type_id,
		"org.baseurl.yum", 0))

static void
fcmdr_yum_backend_build_profiles_table (FCmdrProfile *profile,
                                        GHashTable *profiles_table)
{
	const gchar *uid;
	gchar *basename;
	gchar *filename;

	uid = fcmdr_profile_get_uid (profile);
	basename = g_strdup_printf ("fleet-commander-%s.repo", uid);
	filename = g_build_filename (FCMDR_YUM_REPOS_DIR, basename, NULL);

	/* Takes ownership of filename string. */
	g_hash_table_replace (
		profiles_table, filename,
		g_object_ref (profile));

	g_free (basename);
}

static void
fcmdr_yum_backend_purge_old_profiles (GHashTable *profiles_table,
                                      const gchar *dirname)
{
	GDir *dir;
	const gchar *basename;
	GError *local_error = NULL;

	dir = g_dir_open (dirname, 0, &local_error);

	if (local_error != NULL) {
		g_critical (
			"Failed to open directory: %s: %s",
			dirname, local_error->message);
		g_error_free (local_error);
		return;
	}

	while ((basename = g_dir_read_name (dir)) != NULL) {
		gchar *filename;

		/* Make sure we only delete our own files! */

		if (!g_str_has_suffix (basename, ".repo"))
			continue;

		if (!g_str_has_prefix (basename, "fleet-commander-"))
			continue;

		filename = g_build_filename (dirname, basename, NULL);

		if (!g_hash_table_contains (profiles_table, filename))
			g_unlink (filename);

		g_free (filename);
	}

	g_dir_close (dir);
}

static void
fcmdr_yum_backend_apply_one_profile (const gchar *filename,
                                     FCmdrProfile *profile,
                                     FCmdrServiceBackend *backend)
{
	JsonNode *json_node;
	GString *contents;
	gchar *string;
	GError *local_error = NULL;

	/* The profile may not have settings for this backend. */
	json_node = fcmdr_service_backend_dup_settings (backend, profile);
	if (json_node == NULL)
		return;

	g_return_if_fail (JSON_NODE_HOLDS_VALUE (json_node));

	contents = g_string_new (FCMDR_YUM_PREAMBLE);

	/* XXX Something somewhere is apparently escaping the already-
	 *     escaped newlines in the JSON string.  Reading something
	 *     about a Jinja2 autoescape option in the Flask docs, but
	 *     not sure if that's relevant.  For now just cope with it
	 *     on the client side. */
	string = g_strcompress (json_node_get_string (json_node));
	g_string_append (contents, string);
	g_free (string);

	g_file_set_contents (
		filename, contents->str, contents->len, &local_error);

	if (local_error != NULL) {
		g_critical (
			"Failed to write file: %s: %s",
			filename, local_error->message);
		g_clear_error (&local_error);
	}

	g_string_free (contents, TRUE);

	json_node_free (json_node);
}

static void
fcmdr_yum_backend_apply_profiles (FCmdrServiceBackend *backend,
                                  GList *profiles)
{
	if (g_mkdir_with_parents (FCMDR_YUM_REPOS_DIR, 0755) == 0) {
		GHashTable *profiles_table;

		profiles_table = g_hash_table_new_full (
			(GHashFunc) g_str_hash,
			(GEqualFunc) g_str_equal,
			(GDestroyNotify) g_free,
			(GDestroyNotify) g_object_unref);

		g_list_foreach (
			profiles,
			(GFunc) fcmdr_yum_backend_build_profiles_table,
			profiles_table);

		fcmdr_yum_backend_purge_old_profiles (
			profiles_table, FCMDR_YUM_REPOS_DIR);

		g_hash_table_foreach (
			profiles_table,
			(GHFunc) fcmdr_yum_backend_apply_one_profile,
			backend);

		g_hash_table_destroy (profiles_table);
	} else {
		g_critical (
			"Failed to make directory: %s: %s",
			FCMDR_YUM_REPOS_DIR, g_strerror (errno));
	}
}

static void
fcmdr_yum_backend_class_init (FCmdrYumBackendClass *class)
{
	FCmdrServiceBackendClass *backend_class;

	backend_class = FCMDR_SERVICE_BACKEND_CLASS (class);
	backend_class->apply_profiles = fcmdr_yum_backend_apply_profiles;
}

static void
fcmdr_yum_backend_init (FCmdrYumBackend *backend)
{
}

